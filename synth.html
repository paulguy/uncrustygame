<!DOCTYPE html>
<html>
    <head>
        <title>synth.h Documentation</title>
        <link href="uncrustygame.css" rel="stylesheet">
    </head>
    <body>
        <img src="cdemo/title.bmp">
<ul><li><a href="#synth.h Documentation">synth.h Documentation</a></li><ul><li><a href="# Definitions "> Definitions </a></li><ul><li><a href="#SYNTH_DEFAULT_FRAGMENT_SIZE">SYNTH_DEFAULT_FRAGMENT_SIZE</a></li><li><a href="#SYNTH_STOPPED_OUTBUFFER">SYNTH_STOPPED_OUTBUFFER</a></li><li><a href="#SYNTH_STOPPED_INBUFFER">SYNTH_STOPPED_INBUFFER</a></li><li><a href="#SYNTH_STOPPED_VOLBUFFER">SYNTH_STOPPED_VOLBUFFER</a></li><li><a href="#SYNTH_STOPPED_SPEEDBUFFER">SYNTH_STOPPED_SPEEDBUFFER</a></li><li><a href="#SYNTH_STOPPED_PHASEBUFFER">SYNTH_STOPPED_PHASEBUFFER</a></li><li><a href="#SYNTH_STOPPED_SLICEBUFFER">SYNTH_STOPPED_SLICEBUFFER</a></li><li><a href="#SYNTH_STOPPED_STARTBUFFER">SYNTH_STOPPED_STARTBUFFER</a></li><li><a href="#SYNTH_STOPPED_LENGTHBUFFER">SYNTH_STOPPED_LENGTHBUFFER</a></li><li><a href="#SynthImportType">SynthImportType</a></li><li><a href="#SynthState">SynthState</a></li><li><a href="#SynthOutputOperation">SynthOutputOperation</a></li><li><a href="#SynthAutoMode">SynthAutoMode</a></li><li><a href="#SynthPlayerMode">SynthPlayerMode</a></li><li><a href="#Synth">Synth</a></li></ul><li><a href="# Global Functions "> Global Functions </a></li><ul><li><a href="#synth_frame_cb_t">synth_frame_cb_t</a></li><li><a href="#synth_type_from_audioformat">synth_type_from_audioformat</a></li><li><a href="#synth_audioformat_from_type">synth_audioformat_from_type</a></li><li><a href="#synth_buffer_from_wav">synth_buffer_from_wav</a></li><li><a href="#synth_print_full_stats">synth_print_full_stats</a></li><li><a href="#synth_get_samples_needed">synth_get_samples_needed</a></li><li><a href="#synth_new">synth_new</a></li><li><a href="#synth_free">synth_free</a></li><li><a href="#synth_open_wav">synth_open_wav</a></li><li><a href="#synth_close_wav">synth_close_wav</a></li><li><a href="#synth_write_wav">synth_write_wav</a></li><li><a href="#synth_get_rate">synth_get_rate</a></li><li><a href="#synth_get_channels">synth_get_channels</a></li><li><a href="#synth_get_fragment_size">synth_get_fragment_size</a></li><li><a href="#synth_has_underrun">synth_has_underrun</a></li><li><a href="#synth_set_enabled">synth_set_enabled</a></li><li><a href="#synth_frame">synth_frame</a></li><li><a href="#synth_invalidate_buffers">synth_invalidate_buffers</a></li><li><a href="#synth_set_fragments">synth_set_fragments</a></li><li><a href="#synth_samples_available">synth_samples_available</a></li><li><a href="#synth_consume_samples">synth_consume_samples</a></li></ul><li><a href="# Buffer Functions "> Buffer Functions </a></li><ul><li><a href="#synth_add_buffer">synth_add_buffer</a></li><li><a href="#synth_free_buffer">synth_free_buffer</a></li><li><a href="#synth_buffer_get_size">synth_buffer_get_size</a></li><li><a href="#synth_get_internal_buffer">synth_get_internal_buffer</a></li><li><a href="#synth_release_buffer">synth_release_buffer</a></li><li><a href="#synth_silence_buffer">synth_silence_buffer</a></li></ul><li><a href="# Player Functions "> Player Functions </a></li><ul><li><a href="#synth_add_player">synth_add_player</a></li><li><a href="#synth_free_player">synth_free_player</a></li><li><a href="#synth_set_player_input_buffer">synth_set_player_input_buffer</a></li><li><a href="#synth_set_player_input_buffer_pos">synth_set_player_input_buffer_pos</a></li><li><a href="#synth_set_player_output_buffer">synth_set_player_output_buffer</a></li><li><a href="#synth_set_player_output_buffer_pos">synth_set_player_output_buffer_pos</a></li><li><a href="#synth_set_player_output_mode">synth_set_player_output_mode</a></li><li><a href="#synth_set_player_volume_mode">synth_set_player_volume_mode</a></li><li><a href="#synth_set_player_volume">synth_set_player_volume</a></li><li><a href="#synth_set_player_volume_source">synth_set_player_volume_source</a></li><li><a href="#synth_set_player_mode">synth_set_player_mode</a></li><li><a href="#synth_set_player_loop_start">synth_set_player_loop_start</a></li><li><a href="#synth_set_player_loop_length">synth_set_player_loop_length</a></li><li><a href="#synth_set_player_start_source">synth_set_player_start_source</a></li><li><a href="#synth_set_player_start_values">synth_set_player_start_values</a></li><li><a href="#synth_set_player_start_granularity">synth_set_player_start_granularity</a></li><li><a href="#synth_set_player_start_mode">synth_set_player_start_mode</a></li><li><a href="#synth_set_player_length_source">synth_set_player_length_source</a></li><li><a href="#synth_set_player_length_values">synth_set_player_length_values</a></li><li><a href="#synth_set_player_length_granularity">synth_set_player_length_granularity</a></li><li><a href="#synth_set_player_length_mode">synth_set_player_length_mode</a></li><li><a href="#synth_set_player_phase_source">synth_set_player_phase_source</a></li><li><a href="#synth_set_player_speed_mode">synth_set_player_speed_mode</a></li><li><a href="#synth_set_player_speed">synth_set_player_speed</a></li><li><a href="#synth_set_player_speed_source">synth_set_player_speed_source</a></li><li><a href="#synth_run_player">synth_run_player</a></li><li><a href="#synth_player_stopped_reason">synth_player_stopped_reason</a></li></ul><li><a href="# Filter Functions "> Filter Functions </a></li><ul><li><a href="#synth_add_filter">synth_add_filter</a></li><li><a href="#synth_free_filter">synth_free_filter</a></li><li><a href="#synth_reset_filter">synth_reset_filter</a></li><li><a href="#synth_set_filter_input_buffer">synth_set_filter_input_buffer</a></li><li><a href="#synth_set_filter_input_buffer_pos">synth_set_filter_input_buffer_pos</a></li><li><a href="#synth_set_filter_buffer">synth_set_filter_buffer</a></li><li><a href="#synth_set_filter_buffer_start">synth_set_filter_buffer_start</a></li><li><a href="#synth_set_filter_slices">synth_set_filter_slices</a></li><li><a href="#synth_set_filter_mode">synth_set_filter_mode</a></li><li><a href="#synth_set_filter_slice">synth_set_filter_slice</a></li><li><a href="#synth_set_filter_slice_source">synth_set_filter_slice_source</a></li><li><a href="#synth_set_filter_output_buffer">synth_set_filter_output_buffer</a></li><li><a href="#synth_set_filter_output_buffer_pos">synth_set_filter_output_buffer_pos</a></li><li><a href="#synth_set_filter_output_mode">synth_set_filter_output_mode</a></li><li><a href="#synth_set_filter_volume_mode">synth_set_filter_volume_mode</a></li><li><a href="#synth_set_filter_volume">synth_set_filter_volume</a></li><li><a href="#synth_set_filter_volume_source">synth_set_filter_volume_source</a></li><li><a href="#synth_run_filter">synth_run_filter</a></li><li><a href="#synth_filter_stopped_reason">synth_filter_stopped_reason</a></li></ul></ul></ul>
<h1 id="synth.h Documentation">synth.h Documentation</h1><p><p>This is the audio portion of the uncrustygame/libcrustygame library.  It deals in managing audio buffers and player structures which handle outputting those buffers to other buffers in memory or to the audio device, using SDL. It should be fairly capable in being able to get basic audio effects and playing out samples and music. </p><p>The idea in how it's to be used is any audio that is to be played is loaded in to its internal buffers, then a player is assigned for those buffers which handles playback.  Many parameters can be modified to affect the way the buffers are played back and other buffers can also be used to control sample-by-sample how playback should be affected for many of the parameters. the player may also output to other internal buffers so multiple stages of effects can be performed and even buffers used to control parameters can be generated in real time for a chain of players to make complex effects. On initialization some number of buffers equal to the number of audio channels will be available.  They can only be used for output, and their size will vary based on how full the buffers are, and other factors. </p></p>
<h2 id=" Definitions "> Definitions </h2>
<code id="SYNTH_DEFAULT_FRAGMENT_SIZE">#define SYNTH_DEFAULT_FRAGMENT_SIZE (512)</code><p><p> try to determine a sane size which is roughly half a frame long at 60 FPS. 48000 / 120 = 400, nearest power of two is 512, user can set more fragments if they need  </p></p><hr>
<code id="SYNTH_STOPPED_OUTBUFFER">#define SYNTH_STOPPED_OUTBUFFER    (0x01)</code><p><p> Synth stopped because the output buffer filled.  </p></p><hr>
<code id="SYNTH_STOPPED_INBUFFER">#define SYNTH_STOPPED_INBUFFER     (0x02)</code><p><p> Synth stopped because the input buffer emptied  </p></p><hr>
<code id="SYNTH_STOPPED_VOLBUFFER">#define SYNTH_STOPPED_VOLBUFFER    (0x04)</code><p><p> Synth stopped because the volume buffer reached the end  </p></p><hr>
<code id="SYNTH_STOPPED_SPEEDBUFFER">#define SYNTH_STOPPED_SPEEDBUFFER  (0x08)</code><p><p> Synth stopped because the speed buffer reached the end  </p></p><hr>
<code id="SYNTH_STOPPED_PHASEBUFFER">#define SYNTH_STOPPED_PHASEBUFFER  (0x10)</code><p><p> Synth stopped because the phase buffer reached the end  </p></p><hr>
<code id="SYNTH_STOPPED_SLICEBUFFER">#define SYNTH_STOPPED_SLICEBUFFER  (0x20)</code><p><p> Synth stopped because the slice buffer reached the end  </p></p><hr>
<code id="SYNTH_STOPPED_STARTBUFFER">#define SYNTH_STOPPED_STARTBUFFER  (0x40)</code><p><p> Synth stopped because the loop start buffer reached the end  </p></p><hr>
<code id="SYNTH_STOPPED_LENGTHBUFFER">#define SYNTH_STOPPED_LENGTHBUFFER (0x80)</code><p><p> Synth stopped because the loop length buffer reached the end  </p></p><hr>
<code id="SynthImportType">typedef enum {
    SYNTH_TYPE_INVALID = 0,
    SYNTH_TYPE_U8 = 1,
    SYNTH_TYPE_S16 = 2,
    SYNTH_TYPE_F32 = 3,
    SYNTH_TYPE_F64 = 4
} SynthImportType;</code><p><p> most common formats  </p></p><hr>
<code id="SynthState">typedef enum {
    SYNTH_STOPPED = 0,
    SYNTH_ENABLED = 1,
    SYNTH_RUNNING = 2
} SynthState;</code><p><p> synthesizer state: STOPPED: not running ENABLED: just started but hasn't generated any audio yet RUNNING: started and has generated audio </p></p><hr>
<code id="SynthOutputOperation">typedef enum {
    SYNTH_OUTPUT_REPLACE = 0,
    SYNTH_OUTPUT_ADD = 1
} SynthOutputOperation;</code><p><p> REPLACE: Replace buffer contents with output. ADD: Add/mix output with buffer contents. </p></p><hr>
<code id="SynthAutoMode">typedef enum {
    SYNTH_AUTO_CONSTANT = 0,
    SYNTH_AUTO_SOURCE = 1
} SynthAutoMode;</code><p><p> CONSTANT: Use a constant value. SOURCE: Use values sequentially from another buffer, possibly modified by a constant. </p></p><hr>
<code id="SynthPlayerMode">typedef enum {
    SYNTH_MODE_ONCE = 0,
    SYNTH_MODE_LOOP = 1,
    SYNTH_MODE_PHASE_SOURCE = 2
} SynthPlayerMode;</code><p><p> ONCE: Play once then stop. LOOP: Wrap play position by play bounds. PHASE_SOURCE: Determine read position by values read from a buffer. </p></p><hr>
<code id="Synth">typedef struct Synth_s Synth;</code><p><p> the synth  </p></p><hr>
<h2 id=" Global Functions "> Global Functions </h2>
<code id="synth_frame_cb_t">typedef int (*synth_frame_cb_t)(void *priv, Synth *s);</code><p><p>The callback which you, the programmer, provide for the synth engine to indicate it needs audio, in response to synth_frame() being called to try to top up the audio buffers.  May be called several times per synth_frame() call or not at all if the buffers are full. </p><p>priv     A pointer you provided to synth_new s        The relevant Synth structure which needs updating return   number of samples written to output, negative to indicate to the          engine there was some problem to indicate back to the synth_frame          call. </p></p><hr>
<code id="synth_type_from_audioformat">SynthImportType synth_type_from_audioformat(SDL_AudioFormat format);</code><p><p>Convert from an SDL_AudioFormat to a SynthImportType.  Not all formats supported by SDL are supported by the synth engine so it can return SYNTH_TYPE_INVALID if not. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>format</td><td>The SDL_AudioFormat to convert</td></tr><tr><td>return</td><td>The SynthImportType you can provide to synth_add_buffer</td></tr></tbody></table><hr>
<code id="synth_audioformat_from_type">SDL_AudioFormat synth_audioformat_from_type(SynthImportType type);</code><p><p>Converts a SynthImportType to an SDL_AudioFormat.  Returns 0 if it's not a valid SynthImportType (which should be an invalid/impossible SDL_AudioFormat) </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>type</td><td>The SynthImportType to convert</td></tr><tr><td>return</td><td>The SDL_AudioFormat</td></tr></tbody></table><hr>
<code id="synth_buffer_from_wav">int synth_buffer_from_wav(Synth *s,
                          const char *filename,
                          unsigned int *rate,
                          const char *name);</code><p><p>Helper function to take a path to a WAV file and return a synth buffer handle.  The sample rate from the WAV file is also returned. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>The Synth structure</td></tr><tr><td>filename</td><td>A path to a WAV file to load.</td></tr><tr><td>rate</td><td>A pointer to an unsigned int that will be populated with the sample</td></tr><tr><td>rate</td><td>A pointer to an unsigned int that will be populated with the sample rate of the WAV file.</td></tr><tr><td>name</td><td>optional name or NULL to use the filename</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_print_full_stats">void synth_print_full_stats(Synth *s);</code><p><p>Output information about the provided Synth structure, all loaded buffers and all players.  Outputs through the log callback provided associated with the synth structure. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>The Synth structure </td></tr></tbody></table><hr>
<code id="synth_get_samples_needed">unsigned int synth_get_samples_needed(Synth *s);</code><p><p>Get the amount of samples necessary to top up the audio buffers.  Usually useful during the audio callback. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>return</td><td>number of samples needed</td></tr></tbody></table><hr>
<code id="synth_new">Synth *synth_new(const char *filename,
                 int opendev,
                 const char *devname,
                 synth_frame_cb_t synth_frame_cb,
                 void *synth_frame_priv,
                 log_cb_return_t log_cb,
                 void *log_priv,
                 unsigned int rate,
                 unsigned int channels,
                 unsigned int fragsize,
                 SynthImportType format);</code><p><p>Create a new synth structure.  The structure is "stopped" on creation.  The specified format might not be what is gotten. If opendev is 0, don't try to open an audio device, just output to a WAV file or purely buffers consumed by the client application. In this case, it doesn't need to be started (doing so is a no-op, with a warning) and synth_frame will instead return the amount of samples written, or 0 if none could be written, and still -1 on error. Some method of determining completion will have to be determined by the library user. The filename may be NULL to simply run the synth with no output, to be used by the internal buffers methods.  synth_frame shouldn't be called in this case and instead synth_consume_samples should be used to advance things. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>filename</td><td>Filename to output to as WAV or NULL to not open a file.</td></tr><tr><td>opendev</td><td>Whether an audio output device should be opened at all.</td></tr><tr><td>devname</td><td>A device name provided by SDL_GetAudioDeviceName() or NULL</td></tr><tr><td>devname</td><td>A device name provided by SDL_GetAudioDeviceName() or NULL to let SDL make the decision.</td></tr><tr><td>synth_frame_cb</td><td>The callback which will be called when synth_get_rate is</td></tr><tr><td>synth_frame_cb</td><td>The callback which will be called when synth_get_rate is called to request that more audio may be needed.</td></tr><tr><td>synth_frame_priv</td><td>some pointer which you provide which will be passed in to</td></tr><tr><td>synth_frame_priv</td><td>some pointer which you provide which will be passed in to the synth_frame_cb calls.</td></tr><tr><td>synth_log_cb</td><td>Callback for logging.</td></tr><tr><td>synth_log_priv</td><td>Some pointer which you provide which will be passed on the</td></tr><tr><td>synth_log_priv</td><td>Some pointer which you provide which will be passed on the synth_log_cb calls.</td></tr><tr><td>rate</td><td>The prefered sample rate.</td></tr><tr><td>channels</td><td>The prefered channels count.</td></tr><tr><td>fragsize</td><td>Some fragment size, see SYNTH_DEFAULT_FRAGMENT_SIZE.</td></tr><tr><td>format</td><td>the format, supported formats are:</td></tr><tr><td>format</td><td>the format, supported formats are: SYNTH_TYPE_U8</td></tr><tr><td>format</td><td>the format, supported formats are: SYNTH_TYPE_U8 SYNTH_TYPE_S16</td></tr><tr><td>format</td><td>the format, supported formats are: SYNTH_TYPE_U8 SYNTH_TYPE_S16 SYNTH_TYPE_F32</td></tr><tr><td>return</td><td>The new Synth structure.</td></tr></tbody></table><hr>
<code id="synth_free">void synth_free(Synth *s);</code><p><p>Stop the synth, free any buffers created by it and close the associated SDL_audio device. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>The Synth structure.</td></tr><tr><td>return</td><td>void</td></tr></tbody></table><hr>
<code id="synth_open_wav">int synth_open_wav(Synth *s, const char *filename);</code><p><p>Open a WAV file for output on a currently running synthesizer, for recording the output to a file as it's output. s        the Synth structure filename the file to open </p></p><hr>
<code id="synth_close_wav">int synth_close_wav(Synth *s);</code><p><p>Close an open WAV file.  When done, synth_free() should be called, though. s        the Synth structure return   0 on successn -1 on error (although the file will likely have been </p></p><hr>
<code id="synth_write_wav">int synth_write_wav(Synth *s, unsigned int samples);</code><p><p>Write data to a wav file.  This is used when there is no SDL audio output. synth_frame should be called first and its return value should be passed to this function's samples argumet. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>d</td><td>the Synth structure</td></tr><tr><td>samples</td><td>the number of samples to write</td></tr><tr><td>return</td><td>0 on success, -1 on error, and the file will be closed</td></tr></tbody></table><hr>
<code id="synth_get_rate">unsigned int synth_get_rate(Synth *s);</code><p><p>Get the sample rate the audio device was initialized with, may be different from what was requested. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>The Synth structure.</td></tr><tr><td>return</td><td>device sample rate</td></tr></tbody></table><hr>
<code id="synth_get_channels">unsigned int synth_get_channels(Synth *s);</code><p><p>Get the channel count the audio device was initialized with, may be different from what was requested.  Channel order should be the same as SDL_audio, and it might end up being some "surround" mode, in which case there will be many initial output buffers.  Note that surround/multichannel output beyond stereo hasn't been tested and might not work at all. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>return</td><td>the channel count</td></tr></tbody></table><hr>
<code id="synth_get_fragment_size">unsigned int synth_get_fragment_size(Synth *s);</code><p><p>Get the fragment size the audio device was initialized with.  Can be useful in calculating, for example, how many fragments there will be in 1 frame of video, or to determine how much latency a certain amount of fragments will add. </p></p><p>See: <a href="#synth_set_fragments">synth_set_fragments</a></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>return</td><td>fragment size in samples.</td></tr></tbody></table><hr>
<code id="synth_has_underrun">int synth_has_underrun(Synth *s);</code><p><p>Returns non-zero if there was an underrun resulting from the buffers being depleted before a synth_frame was called and fulfilled.  At this point there will probably have been pops and/or crackles or some other disruption of audio and that either some external process has held things up or the rest of your program is running slowly/lagging behind or that the fragment count is simply too low. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>return</td><td>0 if no underrun has occurred, non-zero if it has</td></tr></tbody></table><hr>
<code id="synth_set_enabled">int synth_set_enabled(Synth *s, int enabled);</code><p><p>Set the enabled state of the output, 0 to stop the output and non-zero to start it.  Nothing happens other than some internal state being set up. The next call to synth_frame will try to request buffers filled, then start the audio output. This doesn't do anything if there's no device being output to. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>enabled</td><td>0 to stop, non-zero to start</td></tr><tr><td>return</td><td>0 on success, -1 on failure, including frame callback failures</td></tr></tbody></table><hr>
<code id="synth_frame">int synth_frame(Synth *s);</code><p><p>Indicate that it's a good time for the frame callback to be run to fill up the buffers. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>return</td><td>negative on failure, including frame callback failures</td></tr><tr><td>return</td><td>negative on failure, including frame callback failures >=0 to indicate amount of samples output</td></tr></tbody></table><hr>
<code id="synth_invalidate_buffers">void synth_invalidate_buffers(Synth *s);</code><p><p>Invalidate the output buffers.  Data in them already will not be played. Probably best to do this when it's not enabled.  It will lock the audio device while messing with buffer state so it should be safe, though. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>return</td><td>void</td></tr></tbody></table><hr>
<code id="synth_set_fragments">int synth_set_fragments(Synth *s,
                        unsigned int fragments);</code><p><p>Set the number of fragments that should be buffered internally.  Higher values will add more latency but will buy more time between synth_frame calls.  This must be called at least once before starting and can't be called while the engine is running, it must be stopped first. </p></p><p>See: <a href="#synth_get_fragment_size">synth_get_fragment_size</a></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>fragments</td><td>the size of the internal buffer, in fragments</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_samples_available">unsigned int synth_samples_available(Synth *s);</code><p><p>Get the number of samples available in the output buffers. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>return</td><td>the number of samples available</td></tr></tbody></table><hr>
<code id="synth_consume_samples">void synth_consume_samples(Synth *s, unsigned int consumed);</code><p><p>Mark a certain amount of buffered audio as used/processed and that memory can now be used for more data. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>consumed</td><td>the amount to mark as consumed</td></tr><tr><td>return</td><td>void</td></tr></tbody></table><hr>
<h2 id=" Buffer Functions "> Buffer Functions </h2>
<code id="synth_add_buffer">int synth_add_buffer(Synth *s,
                     SynthImportType type,
                     void *data,
                     unsigned int size,
                     const char *name);</code><p><p>Add a new buffer, given type, data and a size, in samples.  NULL can be given as data to create a "silent" buffer which can be output to.  Everything is internally converted to 32 bit float format, with integer formats scaled from -1.0 to +1.0, then output to whatever is appropriate for the audio device.  All buffers are mono by nature.  Stereo effects would be achieved by writing to the individual output buffers. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>type</td><td>The data format in "data"</td></tr><tr><td>data</td><td>the data</td></tr><tr><td>size</td><td>the size of the data in samples</td></tr><tr><td>name</td><td>optional name or NULL</td></tr><tr><td>return</td><td>the buffer handle or -1 on failure</td></tr></tbody></table><hr>
<code id="synth_free_buffer">int synth_free_buffer(Synth *s, unsigned int index);</code><p><p>Free a buffer and its memory. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the buffer handle index</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_buffer_get_size">int synth_buffer_get_size(Synth *s, unsigned int index);</code><p><p>Get the size in samples of a buffer. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the buffer handle index</td></tr><tr><td>return</td><td>size in samples or -1 on failure</td></tr></tbody></table><hr>
<code id="synth_get_internal_buffer">int synth_get_internal_buffer(Synth *s, unsigned int index, float **buf);</code><p><p>Get the pointer to the internal buffer data.  This can either be a normal buffer or an output buffer.  Behavior differs a fair bit between the two: Normal buffers will just return the fixed size and pointer to the beginning of the buffer, and their reference count will be increased. Output buffers have no reference counts but may be internally "split" since it's a ring buffer, so to get the full output buffer, this must be called twice, which the first, second, both or neither may return 0 length and a NULL pointer for buf. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the buffer handle index</td></tr><tr><td>buf</td><td>a pointer to a pointer which will be assigned to the pointer to</td></tr><tr><td>buf</td><td>a pointer to a pointer which will be assigned to the pointer to the buffer.</td></tr><tr><td>return</td><td>size in samples or -1 on failure</td></tr></tbody></table><hr>
<code id="synth_release_buffer">int synth_release_buffer(Synth *s, unsigned int index);</code><p><p>Release the reference to the inernal buffer data.  The buffer data shouldn't be used after this until a new reference is acquired.  Output buffers must be released before audio playback will continue. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the buffer handle index</td></tr><tr><td>return</td><td>0 on success or -1 on failure</td></tr></tbody></table><hr>
<code id="synth_silence_buffer">int synth_silence_buffer(Synth *s,
                         unsigned int index,
                         unsigned int start,
                         unsigned int length);</code><p><p>Silence a buffer which contains audio. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>The Synth structure</td></tr><tr><td>index</td><td>The buffer index to silence</td></tr><tr><td>start</td><td>The start sample to silence</td></tr><tr><td>length</td><td>The length of the range to silence in samples</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<h2 id=" Player Functions "> Player Functions </h2>
<code id="synth_add_player">int synth_add_player(Synth *s,
                     unsigned int inBuffer,
                     const char *name);</code><p><p>Create a player.  These control all the input and output of buffers and how they will be played back. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>The Synth structure</td></tr><tr><td>inBuffer</td><td>The initial input buffer for the new player</td></tr><tr><td>name</td><td>optional name or NULL</td></tr><tr><td>return</td><td>the new player handle or -1 on failure</td></tr></tbody></table><hr>
<code id="synth_free_player">int synth_free_player(Synth *s, unsigned int index);</code><p><p>Free a player.  Doesn't free any buffers and doesn't necessarily free any memory.  In fact, players are kept in an internal array that only grows logarithmically as needed, so lots and lots of players will only grow that, while freeing them won't shrink it.  The structure isn't particularly huge or anything but it's maybe something to consider to avoid memory leaks. Player structures in the array are reused, though when they've been freed. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>The Synth structure</td></tr><tr><td>index</td><td>the player index to free</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_input_buffer">int synth_set_player_input_buffer(Synth *s,
                                  unsigned int index,
                                  unsigned int inBuffer);</code><p><p>Set the input buffer handle for the player.  Only buffers created can be input buffers, not the final output buffer handles, as their contents and size is unpredictable. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>The Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>inBuffer</td><td>the buffer to apply to the player as input</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_input_buffer_pos">int synth_set_player_input_buffer_pos(Synth *s,
                                      unsigned int index,
                                      float inPos);</code><p><p>Set the position in samples that the input buffer should start playing from. Negative positions indicate a position from the end. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>inPos</td><td>the position to start playing at.  Internally this value is a</td></tr><tr><td>inPos</td><td>the position to start playing at.  Internally this value is a floating point value so fractional position information is retained</td></tr><tr><td>inPos</td><td>the position to start playing at.  Internally this value is a floating point value so fractional position information is retained for non-integer playback speeds</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_output_buffer">int synth_set_player_output_buffer(Synth *s,
                                   unsigned int index,
                                   unsigned int outBuffer);</code><p><p>Set a buffer to output to, either a buffer which has been created or to a final output buffer. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the played index to update</td></tr><tr><td>outBuffer</td><td>the buffer which the player should output to</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_output_buffer_pos">int synth_set_player_output_buffer_pos(Synth *s,
                                       unsigned int index,
                                       int outPos);</code><p><p>Set the output buffer position.  In the case of final output buffers, this is relative to the position which needs to be filled from, and the length being the amount of samples needed, otherwise it's just the whole output buffer.  Since buffers are always filled sample by sample, this value is an integer.  Negative positions indicate a position from the end. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>outPos</td><td>the position to start output from</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_output_mode">int synth_set_player_output_mode(Synth *s,
                                 unsigned int index,
                                 SynthOutputOperation outOp);</code><p><p>Set the output mode or operation for the player. REPLACE: just replace the value in the buffer with the result of the          player's output ADD: add(mix) the player's output with the buffer's value, there is no      protection from clipping but internally, buffers are 32 bit float so      values swinging larger than -1.0 to +1.0 can be compressed down,      otherwise, I have no idea what it would sound like when SDL passes it      on to the audio device. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>outOp</td><td>the output mode/operation</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_volume_mode">int synth_set_player_volume_mode(Synth *s,
                                 unsigned int index,
                                 SynthAutoMode volMode);</code><p><p>Set the volume mode. CONSTANT: Simply multiply each output sample by the constant set volume. SOURCE: Multiply each output sample by the values from a buffer.  Each         sample output by the player is multiplied by the samples in the         buffer in sequence, as well as the constant volume.         Can be used for envelopes or amplitude modulation effects if you're         extra hopeful things work properly. </p></p><p>See: <a href="#player_set_player_volume,">player_set_player_volume,</a> <a href="#player_set_player_volume_source">player_set_player_volume_source</a></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>volMode</td><td>the volume mode</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_volume">int synth_set_player_volume(Synth *s,
                            unsigned int index,
                            float volume);</code><p><p>Set the constant player volume.  0.0 to mute, 1.0 for original volume, greater values to amplify, lesser values to make it quieter, negative values to invert, if you really want to. </p></p><p>See: <a href="#synth_set_player_volume_mode">synth_set_player_volume_mode</a></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>volume</td><td>the value to multiply the channel output by.  1.0 for no change</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_volume_source">int synth_set_player_volume_source(Synth *s,
                                   unsigned int index,
                                   unsigned int volBuffer);</code><p><p>Set the player volume source.  Must be a created buffer.  The position which is read from starts at 0 and is read sequentially forward until its end. Each call resets the position to 0. </p></p><p>See: <a href="#synth_set_player_volume_mode">synth_set_player_volume_mode</a></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>volBuffer</td><td>the buffer index</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_mode">int synth_set_player_mode(Synth *s,
                          unsigned int index,
                          SynthPlayerMode mode);</code><p><p>Set the playback mode for the player. ONCE: Play the sample once then stop once the end is reached. LOOP: Continuously play the sample until the loop end is reached then       continue back to the loop start indefinitely. PHASE_SOURCE: Read phase source from a buffer, where 0.0 represents the loop               start position of the input buffer and 1.0 represents the loop               end position.  This overrides any speed settings.               I guess this can be used for like frequency modulation effects               or something, I'm not entirely sure how that works but I just               figured someone might want to mess around with something weird               like this. See: synth_set_player_loop_start      synth_set_player_loop_end      synth_set_player_phase_source </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>mode</td><td>the playback mode</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_loop_start">int synth_set_player_loop_start(Synth *s,
                                unsigned int index,
                                int loopStart);</code><p><p>Set loop start, or phase source start position.  A negative value indicates an offset from the end. </p></p><p>See: <a href="#synth_set_player_mode">synth_set_player_mode</a></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>loopStart</td><td>the starting sample to loop from</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_loop_length">int synth_set_player_loop_length(Synth *s,
                                 unsigned int index,
                                 unsigned int loopLength);</code><p><p>Set loop length, or phase source 1.0 value.  A negative value indicates the buffer's end </p></p><p>See: <a href="#synth_set_player_mode">synth_set_player_mode</a></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>loopLength</td><td>the length to loop</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_start_source">int synth_set_player_start_source(Synth *s,
                                  unsigned int index,
                                  unsigned int startBuffer);</code><p><p>Set the source buffer for start position automation. </p></p><p>See: <a href="#synth_set_player_volume_source">synth_set_player_volume_source</a></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>startBuffer</td><td>the source buffer</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_start_values">int synth_set_player_start_values(Synth *s,
                                  unsigned int index,
                                  unsigned int startValues);</code><p><p>Set the number of discrete values to fall on. </p></p><p>See: <a href="#synth_set_player_start_granularity">synth_set_player_start_granularity</a></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>startValues</td><td>the number of values</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_start_granularity">int synth_set_player_start_granularity(Synth *s,
                                       unsigned int index,
                                       unsigned int startGranularity);</code><p><p>Set the positional granularity or distance between values. </p></p><p>See: <a href="#synth_set_player_start_granularity">synth_set_player_start_granularity</a></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>startGranularity</td><td>the distance between values</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_start_mode">int synth_set_player_start_mode(Synth *s,
                                unsigned int index,
                                SynthAutoMode startMode);</code><p><p>Mode for loop start position automation. See: synth_set_player_mode      synth_set_player_length_mode </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>startMode</td><td>the loop start mode</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_length_source">int synth_set_player_length_source(Synth *s,
                                   unsigned int index,
                                   unsigned int lengthBuffer);</code><p><p>Set the source buffer for length automation. </p></p><p>See: <a href="#synth_set_player_volume_source">synth_set_player_volume_source</a></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>startBuffer</td><td>the source buffer</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_length_values">int synth_set_player_length_values(Synth *s,
                                   unsigned int index,
                                   unsigned int lengthValues);</code><p><p>Set the number of discrete values to fall on. </p></p><p>See: <a href="#synth_set_player_length_granularity">synth_set_player_length_granularity</a></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>lengthValues</td><td>the number of values</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_length_granularity">int synth_set_player_length_granularity(Synth *s,
                                        unsigned int index,
                                        unsigned int lengthGranularity);</code><p><p>Set the positional granularity or distance between values. </p></p><p>See: <a href="#synth_set_player_length_granularity">synth_set_player_length_granularity</a></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>lengthGranularity</td><td>the distance between values</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_length_mode">int synth_set_player_length_mode(Synth *s,
                                 unsigned int index,
                                 SynthAutoMode lengthMode);</code><p><p>Mode for loop length automation. See: synth_set_player_mode      synth_set_player_start_mode </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>startMode</td><td>the loop start mode</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_phase_source">int synth_set_player_phase_source(Synth *s,
                                   unsigned int index,
                                   unsigned int phaseBuffer);</code><p><p>Set the buffer to read phase source samples from, similar rules as volume source, except instead of multiplying the output by each sample, input buffer samples will be referenced based on the loop start and end range given source buffer samples from 0.0 to +1.0. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>phaseBuffer</td><td>the buffer to get phase source samples from</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_speed_mode">int synth_set_player_speed_mode(Synth *s,
                                unsigned int index,
                                SynthAutoMode speedMode);</code><p><p>Set the player's speed mode.  Same rules as volume mode, just affects the rate at which input buffer samples are advanced. See: synth_set_player_speed      synth_set_player_volume_mode </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>speedMode</td><td>the speed mode</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_speed">int synth_set_player_speed(Synth *s,
                           unsigned int index,
                           float speed);</code><p><p>Sets the constant player speed. </p></p><p>See: <a href="#synth_set_player_speed_mode">synth_set_player_speed_mode</a></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>speed</td><td>the constant player speed</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_player_speed_source">int synth_set_player_speed_source(Synth *s,
                                  unsigned int index,
                                  unsigned int speedBuffer);</code><p><p>Sets the source for playback speed. </p></p><p>See: <a href="#synth_set_player_speed_mode">synth_set_player_speed_mode</a></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to update</td></tr><tr><td>speedBuffer</td><td>the buffer to use for speed samples</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_run_player">int synth_run_player(Synth *s,
                     unsigned int index,
                     unsigned int reqSamples);</code><p><p>Actually run the player, given all the criteria given for some number of samples or until some source is depleted. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index to run</td></tr><tr><td>reqSamples</td><td>the number of samples desired</td></tr><tr><td>return</td><td>the number of samples generated before something ran out, or -1 on failure</td></tr></tbody></table><hr>
<code id="synth_player_stopped_reason">int synth_player_stopped_reason(Synth *syn, unsigned int index);</code><p><p>Determine criteria for why the player stopped. </p></p><p>See: <a href="#SYNTH_STOPPED_*">SYNTH_STOPPED_*</a></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the player index</td></tr><tr><td>return</td><td>A bitfield of reasons.</td></tr></tbody></table><hr>
<h2 id=" Filter Functions "> Filter Functions </h2>
<code id="synth_add_filter">int synth_add_filter(Synth *s,
                     unsigned int inBuffer,
                     unsigned int size,
                     const char *name);</code><p><p>Create a new filter. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>inBuffer</td><td>the buffer to apply a filter to</td></tr><tr><td>size</td><td>the size of the filter (cannot be changed)</td></tr><tr><td>name</td><td>optional name or NULL</td></tr><tr><td>return</td><td>the new filter handle or -1 on failure;</td></tr></tbody></table><hr>
<code id="synth_free_filter">int synth_free_filter(Synth *s, unsigned int index);</code><p><p>Free the filter, and any of its memory, see buffer/player for memory management notes. See synth_free_buffer, synth_free_player </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the filter handle index to free</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_reset_filter">int synth_reset_filter(Synth *s, unsigned int index);</code><p><p>Reset the filter accumulation state, so if it's started to be used on another buffer, it won't have weird discontinuity from previous processed content. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the filter to reset</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_filter_input_buffer">int synth_set_filter_input_buffer(Synth *s,
                                  unsigned int index,
                                  unsigned int inBuffer);</code><p><p>Set the buffer to apply a filter to. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the filter to update</td></tr><tr><td>inBuffer</td><td>the input buffer index</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_filter_input_buffer_pos">int synth_set_filter_input_buffer_pos(Synth *s,
                                      unsigned int index,
                                      int inPos);</code><p><p>Sets the starting position on processing the input buffer. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the filter to update</td></tr><tr><td>inPos</td><td>the position in the buffer, in samples</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_filter_buffer">int synth_set_filter_buffer(Synth *s,
                            unsigned int index,
                            unsigned int filterBuffer);</code><p><p>Set the buffer containing the filter kernel(s) this filter should use. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the filter to update</td></tr><tr><td>filterBuffer</td><td>the index of the buffer containing filter kernels</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_filter_buffer_start">int synth_set_filter_buffer_start(Synth *s,
                                  unsigned int index,
                                  int startPos);</code><p><p>Set the position in the buffer where kernel(s) should start to be referenced from. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the filter to update</td></tr><tr><td>startPos</td><td>the sample where the filter(s) start</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_filter_slices">int synth_set_filter_slices(Synth *s,
                            unsigned int index,
                            unsigned int slices);</code><p><p>Set the number of consecutive filter kernels starting from the start position which are in the filter buffer. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the filter to update</td></tr><tr><td>slices</td><td>the number of slices</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_filter_mode">int synth_set_filter_mode(Synth *s,
                          unsigned int index,
                          SynthAutoMode mode);</code><p><p>Set whether the filter slice is a constant value (CONSTANT) or whether a buffer should be read to determine which slice should be used per input sample (SOURCE). </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the filter to update</td></tr><tr><td>mode</td><td>the filter mode</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_filter_slice">int synth_set_filter_slice(Synth *s,
                           unsigned int index,
                           int slice);</code><p><p>Set the filter slice value to use either in constant mode or the first slice in slice buffer source mode. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the filter to update</td></tr><tr><td>slice</td><td>the slice index</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_filter_slice_source">int synth_set_filter_slice_source(Synth *s,
                                  unsigned int index,
                                  unsigned int sliceBuffer);</code><p><p>Provide the source buffer for slices, valid values are 0.0 to 1.0, everything else will just wrap between those values.  0.0 will be the Nth filter past startPos and 1.0 will be the last numbered filter slice, and values in between will be which is linearly nearest.  Where N is the first slice value. </p></p><p>See: <a href="#synth_set_filter_slice">synth_set_filter_slice</a></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>indxx</td><td>the filter to update</td></tr><tr><td>sliceBuffer</td><td>The buffer containing the continuous slice selections</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_filter_output_buffer">int synth_set_filter_output_buffer(Synth *s,
                                   unsigned int index,
                                   unsigned int outBuffer);</code><p><p>Set the buffer to be output to. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>theSynth structure</td></tr><tr><td>index</td><td>the filter to update</td></tr><tr><td>outBuffer</td><td>the buffer to output to</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_filter_output_buffer_pos">int synth_set_filter_output_buffer_pos(Synth *s,
                                       unsigned int index,
                                       int outPos);</code><p><p>Set the buffer output position. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the filter to update</td></tr><tr><td>outPos</td><td>the position of the output buffer to output to</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_filter_output_mode">int synth_set_filter_output_mode(Synth *s,
                                 unsigned int index,
                                 SynthOutputOperation outOp);</code><p><p>Set the filter's output mode.  Either overwrite values in the output buffer (REPLACE) or add/mix them together (ADD). </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the filter to update</td></tr><tr><td>outOp</td><td>the output operation</td></tr><tr><td>return</td><td>0 on success, -1 onf ailure</td></tr></tbody></table><hr>
<code id="synth_set_filter_volume_mode">int synth_set_filter_volume_mode(Synth *s,
                                 unsigned int index,
                                 SynthAutoMode volMode);</code><p><p>Set the filter's volume mode.  Either a constant value (CONSTANT) or from a source buffer (SOURCE) with the constant value applied. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the filter to update</td></tr><tr><td>volMode</td><td>the volume mode</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_filter_volume">int synth_set_filter_volume(Synth *s,
                            unsigned int index,
                            float vol);</code><p><p>Set the filter's output volume. </p></p><p>See: <a href="#synth_set_player_volume">synth_set_player_volume</a></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the filter to update</td></tr><tr><td>vol</td><td>the volume</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_set_filter_volume_source">int synth_set_filter_volume_source(Synth *s,
                                   unsigned int index,
                                   unsigned int volBuffer);</code><p><p>Set the source buffer for the filter output volume. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the filter to update</td></tr><tr><td>volBuffer</td><td>the volume buffer index</td></tr><tr><td>return</td><td>0 on success, -1 on failure</td></tr></tbody></table><hr>
<code id="synth_run_filter">int synth_run_filter(Synth *s,
                     unsigned int index,
                     unsigned int reqSamples);</code><p><p>Run the filter for a certain number of samples. </p></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>s</td><td>the Synth structure</td></tr><tr><td>index</td><td>the filter index to run</td></tr><tr><td>reqSamples</td><td>the number of samples to try to run</td></tr><tr><td>return</td><td>the number of samples which could run or -1 on error</td></tr></tbody></table><hr>
<code id="synth_filter_stopped_reason">int synth_filter_stopped_reason(Synth *syn, unsigned int index);

#endif</code><p><p>Get the reason why the filter stopped running. </p></p><p>See: <a href="#SYNTH_STOPPED_*">SYNTH_STOPPED_*</a></p><table class="funcdef"><thead><th>Name</th><th>Description</th></thead><tbody><tr><td>syn</td><td>the Synth structure</td></tr><tr><td>index</td><td>the index of the filter</td></tr><tr><td>requested</td><td>number of samples requested</td></tr><tr><td>returned</td><td>number of samples returned</td></tr><tr><td>return</td><td>the reason or -1 on failure</td></tr></tbody></table><hr>
    </body>
</html>
