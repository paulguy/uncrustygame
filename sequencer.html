<!DOCTYPE html>
<html>
    <head>
        <title>CrustyTracker sequencer format</title>
        <link href="uncrustygame.css" rel="stylesheet">
    </head>
    <body>
        <img src="crustytracker.png">
        <h1>CrustyTracker sequencer format</h1>
        <hr>
        <ul>
            <li><a href="#file-format">General File Format</a></li>
            <li><a href="#format-fields">File Format Fields</a></li>
            <ul>
                <li><a href="#basic-header">Basic Header</a></li>
                <ul>
                    <li><a href="#header-statements">Header Statement Types</a></li>
                </ul>
                <li><a href="#macro">Macro Statement</a></li>
                <ul>
                    <li><a href="#default-macros">Default Macros</a></li>
                    <ul>
                        <li><a href="#output-modes">Output Modes</a></li>
                        <li><a href="#automation-modes">Automation Modes</a></li>
                        <li><a href="#player-modes">Player Modes</a></li>
                    </ul>
                </ul>
                <li><a href="#includes">Include Statement</a></li>
                <li><a href="#tags">Tag Statement</a></li>
                <ul>
                    <li><a href="#meaningful-tags">Meaningful Tags</a></li>
                </ul>
                <li><a href="#buffers">Buffer Statement</a></li>
                <ul>
                    <li><a href="#buffer-types">Buffer Types</a></li>
                </ul>
                <li><a href="#channels">Channel Statement</a></li>
                <ul>
                    <li><a href="#channel-types">Channel Types</a></li>
                </ul>
                <li><a href="#sequence">Sequence Block</a></li>
            </ul>
            <li><a href="#format-types">Specific Format Types</a></li>
            <ul>
                <li><a href="#line-format">Line Format</a></li>
                <li><a href="#parameter-lists">Parameter Lists</a></li>
            </ul>
            <li><a href="#channel-parameters">Channel Parameters</a></li>
            <ul>
                <li><a href="#silence">Silence</a></li>
                <ul>
                    <li><a href="#silence-parameters">Parameters</a></li>
                </ul>
                <li><a href="#player">Player</a></li>
                <ul>
                    <li><a href="#player-parameters">Parameters</a></li>
                    <ul>
                        <li><a href="#parameter-changes">Parameter Changes</a></li>
                    </ul>
                </ul>
                <li><a href="#filter">Filter</a></li>
                <ul>
                    <li><a href="#filter-parameters">Parameters</a></li>
                </ul>
            </ul>
            <li><a href="#debug-output">Debug Output</a></li>
            <ul>
                <li><a href="#debug-parser-output">Debug Parser Output</a></li>
                <li><a href="#debug-sequencer-output">Debug Sequencer Output</a></li>
            </ul>
        </ul>
        <hr>
        <h2 id="file-format">General File Format</h2>
        <p>CrustyTracker has a very line-oriented format (mostly because it's very easy to parse files in to lines and fields in python), so most items are one per line, or split by spaces, and in some cases groups of things are split by '|' (pipe) characters.</p>
        <p>Comments can appear at the end of any line, after a ';' (semicolon).  Nothing sees these comments as they are thrown away immediately.  Lines can be spanned across newlines in a file by ending the line in the \ character, and the rest of the system will just see it as one contiguous line with no extra newlines or anything in between.</p>
        <h2 id="format-fields">File Format Fields</h2>
        <h3 id="basic-header">Basic Header</h3>
        <p>The first line contains only the text 'CrustyTracker', this is basically just used for it to determine that it is a CrustyTracker format sequence.</p>
        <p>The second line contains the version and the number of output channels the file will want.  The current version is version 2 and this version may not be stable.  Version 1 support isn't likely since it was bad and nothing meaningful was written in it that I know of.  The need to specify the channel count for the file is there might be more or less output channels than the file wants.  If there's fewer available, playing the file will fail as there will be no attempt to reduce the number of channels.  If there's more channels, it'll play out of the first N channels that the file declares it needs.</p>
        <p>The rest of the header is a bunch of one-line declarations that begin with the type.  There are currently 4 types then the header is terminated by a line reading 'sequence'.</p>
        <table class="descriptions" id="header-statements">
            <caption>Header Statement Types</caption>
            <thead>
                <tr>
                    <th>Statement Name</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>macro</td>
                    <td>Declares a <a href="#macro">macro</a> which defines a string to replace another string with optional arguments.</td>
                </tr>
                <tr>
                    <td>tag</td>
                    <td>Declares a <a href="#tags">tag</a>.  Can be used for whatever but some are meaningful to the sequencer.</td>
                </tr>
                <tr>
                    <td>buffer</td>
                    <td>Declares a <a href="#buffers">buffer</a>.  This is a piece of memory where audio data is contained or can be output to or input from.</td>
                </tr>
                <tr>
                    <td>channel</td>
                    <td>Declares a <a href="#channels">channel</a> which is a basic operational unit, there are a few types of channels</td>
                </tr>
            </tbody>
        </table>
        <h3 id="macro">Macro Statement</h3>
        <p>Macros replace a string of text with another string of text, and arguments to the macro may be declared which when provided, replace strings of text within the resulting string.</p>
        <p>Macros are of the format:</p>
        <code>macro &lt;name&gt; &lt;argname1&gt; &lt;argname2&gt; &lt;argname3&gt; ...=&lt;string of text&gt;</code>
        <p>Using it in the file just involves having the name followed by all the arguments (Do note that due to a quirk, macros with arguments must have a space at the end of the last argument so it knows that that is the end of the argument)</p>
        <p>The string of text may contain the argument names within it and while the file is read, when the macro is used, those arguments will be replaced with the arguments provided with the macro invocation.</p>
        <h4 id="default-macros">Default Macros</h4>
        <p>There are some default macros that define useful parameter values:</p>
        <table class="descriptions" id="output-modes">
            <caption>Output Modes</caption>
            <thead>
                <tr>
                    <th>Macro Name</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>SYNTH_OUTPUT_REPLACE</td>
                    <td>If a channel has an output mode, this will tell it to replace the data in the buffer it's writing to with its output.</td>
                </tr>
                <tr>
                    <td>SYNTH_OUTPUT_ADD</td>
                    <td>Like above, but will add its output to the data already in the buffer, mixing the values together.</td>
                </tr>
            </tbody>
        </table>
        <table class="descriptions" id="automation-modes">
            <caption>Automation Modes</caption>
            <thead>
                <tr>
                    <th>Macro Name</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>SYNTH_AUTO_CONSTANT</td>
                    <td>For parameters in a channel which may be automated by other buffers, this will define that the parameter will just be a constant value.</td>
                </tr>
                <tr>
                    <td>SYNTH_AUTO_SOURCE</td>
                    <td>Like above, but this will indicate that the parameter should be read from a buffer.  In this case, each output sample from the channel will consume 1 input sample from the buffer which is declared as the source for this parameter.</td>
                </tr>
            </tbody>
        </table>
        <table class="descriptions" id="player-modes">
            <caption>Player Modes</caption>
            <thead>
                <tr>
                    <th>Macro Name</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>SYNTH_MODE_ONCE</td>
                    <td>Indicate that the channel should play its input buffer once then stop at the end, possibly applying a parameter change for the case of input buffer exhaustion, if any.</td>
                </tr>
                <tr>
                    <td>SYNTH_MODE_LOOP</td>
                    <td>Continue to play the input buffer in a loop, and don't stop and don't apply any parameter changes.  Playback may start before (or after) the loop start (or end).  In this case it'll play the part before (or after) the start (or end) before it starts looping.  If it does reach the end (or beginning) of the buffer and the loop end (or start) isn't there, it will exhaust the buffer and apply parameter changes.</td>
                </tr>
                <tr>
                    <td>SYNTH_MODE_PHASE_SOURCE</td>
                    <td>This mode will allow the position fetched from the input buffer to be based on another buffer.  The way this works is that the loop start and loop end will correspond to 0.0 and 1.0 from the phase source buffer.</td>
            </tbody>
        </table>
        <h3 id="includes">Include Statement</h3>
        <p>Related to macro statements:</p>
        <code>include &lt;filemane&gt;</code>
        <p>statements can be used to include a set of macros from a file named by filename.  Any previous macros defined will be evaluated within the included file.</p>
        <h3 id="tags">Tag Statement</h3>
        <p>Tags are</p>
        <code>tag &lt;name&gt;=&lt;value&gt;</code>
        <p>pairs which define whatever you would like, some tags have meaning though.</p>
        <table class="descriptions" id="meaningful-tags">
            <caption>Meaningful Tags</caption>
            <thead>
                <tr>
                    <th>Tag Name</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>tuning</td>
                    <td>Either 1 detuning value can be provided which will detune all the notes by some amount (1.0 is in tune, 0.5 is half frequency, 2.0 is double frequency), or 12 values can be given to detune every note.  Octaves start at C.</td>
                </tr>
                <tr>
                    <td>init</td>
                    <td>Pattern executed once on load for maybe generating samples and other things.  Won't output to any sort of time base so don't have this write to any output buffers.</td>
                </tr>
                <tr>
                    <td>max-request</td>
                    <td>Define how much audio should be requested from a sequence at once.  This is useful for not overfilling intermediate buffers while running the sequence.  This can be done by setting a intermediate buffer size as a macro, then setting this tag and defining buffers with that value.</td>
                </tr>
            </tbody>
        </table>
        <h3 id="buffers">Buffer Statemetn</h3>
        <p>A buffer is a space where audio data can be provided but also can act as intermediate buffers as input and output for channels for processing.  The number of output buffers specified at the top of the file are the first buffers, so if there's 2 channels (stereo), those will be buffers 0 and 1, the rest of the buffers will be in order as declared in the header.</p>
        <table class="descriptions" id="buffer-types">
            <caption>Buffer Types</caption>
            <thead>
                <tr>
                    <th>Type Name</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>filename</td>
                    <td>A path to a WAV file to be provided.  It should be tuned to A but it can be tuned however you want, note values are just a rate offset from A4.</td>
                </tr>
                <tr>
                    <td>integer</td>
                    <td>A number of milliseconds to make of a blank (silent) buffer.  Mostly useful for intermediate processing buffers.</td>
                </tr>
                <tr>
                    <td>external</td>
                    <td>This buffer will be an external buffer provided along with creating the sequence.  May be useful for preventing having to reload audio files between song changes or if many sound effects share base samples or if something needs to be generated at runtime based on the sampling rate.</td>
                </tr>
            </tbody>
        </table>
        <h3 id="channels">Channel Statement</h3>
        <p>Channels are base units which can perform operations on buffers.  They are individually limited, but may be chained to perform more complex effects.</p>
        <p>A channel can be one of 3 values:</p>
        <table class="descriptions" id="channel-types">
            <caption>Channel Types</caption>
            <thead>
                <tr>
                    <th>Type Name</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>silence</td>
                    <td>Simply silences a block of data in a buffer.</td>
                </tr>
                <tr>
                    <td>player</td>
                    <td>Plays a buffer in to a buffer with various parameters.</td>
                </tr>
                <tr>
                    <td>filter</td>
                    <td>Applies a convolution filter to a buffer and outputs to a buffer.</td>
                </tr>
            </tbody>
        </table>
        <p>There's always 1 necessary channel which will always exist for the global parameters.  For now, this channel only contains the step length in milliseconds.  This is always the first column, and its column mask is 1.</p>
        <h3 id="sequence">Sequence Block</h3>
        <p>The sequence block starts with a line defining the entire initial state of parameters for every channel.  This is followed by the number of patterns which will be in the file on its own line, then each pattern will start with the number of lines in that pattern on its own line, followed by that number of lines.  Finally, will be the orders list which is just a list of what order patterns will be played in one after another.</p>
        <h2 id="format-types">Specific Format Types</h2>
        <h3 id="line-format">Line Format</h3>
        <p>Each line may contain all columns, separated by '|' (pipe), so if a sequence has 4 channels, it'll be like:</p>
        <code>channel 1|channel 2|channel 3|channel 4</code>
        <p>Or the line may contain only global paramters which just contains that column ended with only a pipe, of the line can be completely blank with just a pipe.</p>
        <p>Consecutive 0 columns can be crunched down to a single column by putting a negative value for the amount of 0 columns there are to be in a row.</p>
        <code>       Some Examples
━━━━━━━━━━━━━━┯━━━━━━━━━━━━
original      │ replacement
──────────────┼────────────
0             │ -1
0 | 0         │ -2
0 | 0 | 0     │ -3
0 | 0 | 0 | 0 │ -4
            ···</code>
        <p>0 and -1 are equivalent so as to not be silly and confusing.</p>
        <p>Extra space between fields and around the '|'s doesn't matter, except a macro must have a space after the last argument, if it takes arguments.</p>
        <p>There are 2 formats of line in a sequence.  The initial state line.  This appears once and is the first line in the sequence block.  it must have every parameter defined.  A sequence line.  These can specify any number of parameters, or none at all.  The parameters list must start with a bitfield describing which parameters follow after, even if it's 0, for none.</p>
        <p>The bitfield may be followed immediately (no spaces) by an equals sign '=' and some identifier to name that particular parameter list and any spaces which could take a parameter list as an argument, instead of being a number, may have instead, an = followed immediately by an identifier, so a parameter list may reference itself, including within a chain of parameter lists on the same line.  Referencing named parameter lists appearing later is also possible.</p>
        <p>Each column is processed in full for the amount of time or until that column can produce no more data.  Columns are processed from left to right.</p>
        <h3 id="parameter-lists">Parameter Lists</h3>
        <p>Parameters must be provided in a certain order, which depends on the type of channel what order this is and what each parameter does.  Each parameter also has a bitfield value used for sequence lines.  The way those will basically work is that you can simply add the values together, except if in any one field it goes past 9, you continue on with a, b, c, d, e, f.  It'll never be more than f.  This is hexadecimal countinug.</p>
        <p>If a parameter list is to contain another parameter list, it must also start with a bitfield, even if it's 0, for an empty parameter list.</p>
        <h2 id="channel-parameters">Channel Parameters</h2>
        <p>Parameters will be given in order with their bitfield value, a name, and the description of what it does.  All positional values are in milliseconds unless otherwise specified.  All values are integer, unless otherwise specified.</p>
        <p>Anything that takes a buffer parameter as an input buffer must not be an output buffer.  This will fail.  Buffer parameters as output buffers can take any buffers.</p>
        <h3 id="silence">Silence</h3>
        <p>This kind of channel will silence some amount of data, starting from some point in some buffer.</p>
        <table class="parameters" id="silence-parameters">
            <caption>Parameters</caption>
            <thead>
                <tr>
                    <th>#</th>
                    <th>Reason</th>
                    <th>Mask Bit</th>
                    <th>Parameter Name</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>0</td>
                    <td></td>
                    <td>10</td>
                    <td>Output Buffer</td>
                    <td>The buffer which will have silence applied to it.</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td></td>
                    <td>08</td>
                    <td>Output Buffer Position</td>
                    <td>The position where silence will start.</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td></td>
                    <td>04</td>
                    <td>Run Length</td>
                    <td>The length of the silence.  This will trigger the channel to actually process anything.  It has no affect as an initial value and will be reset to 0 on completion.</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>0</td>
                    <td>02</td>
                    <td>Requested Time Met</td>
                    <td>A parameter list applied when the amount of output time requested by Run Length has been completed.</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>1</td>
                    <td>01</td>
                    <td>Output Buffer Filled</td>
                    <td>Applied when the output buffer has reached its and and has been filled.</td>
                </tr>
            </tbody>
        </table>
        <h3 id="player">Player</h3>
        <p>This kind of channel will take in data from an input buffer, and optionally other buffers and use that data to process the input buffer and output it to an output buffer.</p>
        <table class="parameters" id="player-parameters">
            <caption>Parameters</caption>
            <thead>
                <tr>
                    <th>#</th>
                    <th>Reason</th>
                    <th>Mask Bit</th>
                    <th>Parameter Name</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>0</td>
                    <td></td>
                    <td>80000000</td>
                    <td>Input Buffer</td>
                    <td>The buffer which shall be used as the primary source of input for this channel.</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td></td>
                    <td>40000000</td>
                    <td>Input Buffer Position</td>
                    <td>The position to start reading the input buffer from.  This is a value in float because the buffer can be played at any arbitrary rate and the position is kept track of in float.</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td></td>
                    <td>20000000</td>
                    <td>Output Buffer</td>
                    <td>The buffer which will receive the output from this player.</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td></td>
                    <td>10000000</td>
                    <td>Output Buffer Position</td>
                    <td>The position to start writing to the output buffer.</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td></td>
                    <td>08000000</td>
                    <td>Output Mode</td>
                    <td><a href="#output-modes">Either SYNTH_OUTPUT_REPLACE or SYNTH_OUTPUT_ADD.</a></td>
                </tr>
                <tr>
                    <td>5</td>
                    <td></td>
                    <td>04000000</td>
                    <td>Volume</td>
                    <td>The base volume level for this player.  1.0 is no change in volume from the input buffer, lesser values will attenuate, greater values will amplify.</td>
                </tr>
                <tr>
                    <td>6</td>
                    <td></td>
                    <td>02000000</td>
                    <td>Volume Source</td>
                    <td>A buffer to read volume values from if the volume mode is SYNTH_AUTO_SOURCE.  The base volume level is also applied.</td>
                </tr>
                <tr>
                    <td>7</td>
                    <td></td>
                    <td>01000000</td>
                    <td>Volume Mode</td>
                    <td><a href="#automation-modes">Either SYNTH_AUTO_CONSTANT or SYNTH_AUTO_SOURCE.</a></td>
                </tr>
                <tr>
                    <td>8</td>
                    <td></td>
                    <td>00800000</td>
                    <td>Speed</td>
                    <td>This affects the interval at which values are fetched from the input buffer.  This is a complex value which can take many format.  It can be most simply a float value, where 1.0 will play the input buffer with no change in rate, lower values will play slower (by mutiplying up input samples, without interpolation) or faster (also, no antialiasing, so skipped samples are totally not represented).  This value may also be negative, for reverse playback.  This value may also be a note, C-G,A,B.  Followed optionally by a b or a # to flatten or sharpen it a semitone, then followed optionally by a number denoting the octave.  The default octave is 4, and A4 is 1.0 rate.  Additionally to the note, a detune value may be provided directly after '*' character as a float value.  This will detune the note by some number of semitones, or anywhere in between.  This is in addition to any other provided global detuning.</td>
                </tr>
                <tr>
                    <td>9</td>
                    <td></td>
                    <td>00400000</td>
                    <td>Speed Source</td>
                    <td>A buffer to read rate values from to change the speed over time.  This is applied along with the base speed value.</td>
                </tr>
                <tr>
                    <td>10</td>
                    <td></td>
                    <td>00200000</td>
                    <td>Speed Mode</td>
                    <td><a href="#automation-modes">Either SYNTH_AUTO_CONSTANT or SYNTH_AUTO_SOURCE.</a></td>
                </tr>
                <tr>
                    <td>11</td>
                    <td></td>
                    <td>00100000</td>
                    <td>Phase Source</td>
                    <td>The buffer to read phase values from in the case that the Player Mode is SYNTH_MODE_PHASE_SOURCE.</td>
                </tr>
                <tr>
                    <td>12</td>
                    <td></td>
                    <td>00080000</td>
                    <td>Loop Length</td>
                    <td>The length of a loop.  Also the 1.0 position of the phase in the case a buffer is used as the phase source.  0 to set to the end of the buffer.</td>
                </tr>
                <tr>
                    <td>13</td>
                    <td></td>
                    <td>00040000</td>
                    <td>Loop Start</td>
                    <td>The start position of a loop.  Also the 0.0 position of the phase in the case a buffer is used as the phase source.  Negative values start at the end.</td>
                </tr>
                <tr>
                    <td>14</td>
                    <td></td>
                    <td>00020000</td>
                    <td>Player Mode</td>
                    <td><a href="#player-modes">Either SYNTH_MODE_ONCE, SYNTH_MODE_LOOP or SYNTH_MODE_PHASE_SOURCE.</a></td>
                </tr>

                <tr>
                    <td>15</td>
                    <td></td>
                    <td>00010000</td>
                    <td>Start Source</td>
                    <td>Source buffer for start position automation.</td>
                </tr>
                <tr>
                    <td>16</td>
                    <td></td>
                    <td>00008000</td>
                    <td>Start Values</td>
                    <td>Number of start positions.</td>
                </tr>
                <tr>
                    <td>17</td>
                    <td></td>
                    <td>00004000</td>
                    <td>Start Granularity</td>
                    <td>Distance between start positions.</td>
                </tr>
                <tr>
                    <td>18</td>
                    <td></td>
                    <td>00002000</td>
                    <td>Start Mode</td>
                    <td><a href="#automation-modes">Either SYNTH_AUTO_CONSTANT or SYNTH_AUTO_SOURCE.</a></td>
                </tr>
                <tr>
                    <td>19</td>
                    <td></td>
                    <td>00001000</td>
                    <td>Length Source</td>
                    <td>Source buffer for length automation.</td>
                </tr>
                <tr>
                    <td>20</td>
                    <td></td>
                    <td>00000800</td>
                    <td>Length Values</td>
                    <td>Number of length values.</td>
                </tr>
                <tr>
                    <td>21</td>
                    <td></td>
                    <td>00000400</td>
                    <td>Length Granularity</td>
                    <td>Distance between length values.</td>
                </tr>
                <tr>
                    <td>22</td>
                    <td></td>
                    <td>00000200</td>
                    <td>Length Mode</td>
                    <td><a href="#automation-modes">Either SYNTH_AUTO_CONSTANT or SYNTH_AUTO_SOURCE.</a></td>
                </tr>
                <tr>
                    <td>23</td>
                    <td></td>
                    <td>00000100</td>
                    <td>Run Length</td>
                    <td>The amount of output time the player should generate in to an output buffer.</td>
                </tr>
            </tbody>
        </table>
        <h4 id="parameter-changes">Parameter Changes</h4>
        <p>The following values are parameter changes.  They are just another full set of parameter which are applied upon various events.  They may recursively contain any number of additional parameter changes, and they will all be applied in order if processing is stopped for any reason.  If there is no change to be made or if a field should be cleared, this field must be 0, as a bitfield indicating no parameters.  Events will retrigger as its condition is met until the field is cleared.  NOTE: If a column triggers an event then immediately triggers an event again without advancing (this doesn't mean multiple events triggered at once, which is allowed), this column is considered stalled and its requested samples count is set to 0.  This behavior may change or be refined, but won't likely be removed entirely.</p>
        <table class="parameters">
            <thead>
                <tr>
                    <th>#</th>
                    <th>Reason</th>
                    <th>Mask Bit</th>
                    <th>Parameter Name</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>24</td>
                    <td>0</td>
                    <td>00000080</td>
                    <td>Requested Time Met</td>
                    <td>A parameter list applied when the amount of output time requested by Run Length has been completed.</td>
                </tr>
                <tr>
                    <td>25</td>
                    <td>01</td>
                    <td>00000040</td>
                    <td>Output Buffer Filled</td>
                    <td>Applied when the output buffer has reached its and and has been filled.</td>
                </tr>
                <tr>
                    <td>26</td>
                    <td>02</td>
                    <td>00000020</td>
                    <td>Input Buffer Exhausted</td>
                    <td>Applied when the input buffer has reached an end.</td>
                </tr>
                <tr>
                    <td>27</td>
                    <td>04</td>
                    <td>00000010</td>
                    <td>Volume Buffer Exhausted</td>
                    <td>Applied When the volume source buffer has ended.</td>
                </tr>
                <tr>
                    <td>28</td>
                    <td>08</td>
                    <td>00000008</td>
                    <td>Speed Buffer Exhausted</td>
                    <td>Applied when the speed source buffer has ended.</td>
                </tr>
                <tr>
                    <td>29</td>
                    <td>10</td>
                    <td>00000004</td>
                    <td>Phase Buffer Exhausted</td>
                    <td>Applied when the phase source buffer has ended.</td>
                </tr>
                <tr>
                    <td>30</td>
                    <td>10</td>
                    <td>00000002</td>
                    <td>Start Buffer Exhausted</td>
                    <td>Applied when the phase start buffer has ended.</td>
                </tr>
                <tr>
                    <td>31</td>
                    <td>10</td>
                    <td>00000001</td>
                    <td>Length Buffer Exhausted</td>
                    <td>Applied when the phase length buffer has ended.</td>
                </tr>
            </tbody>
        </table>
        <h3 id="filter">Filter</h3>
        <p>This kind of channel will take an input buffer, apply a convolution filter provided as a buffer then output it to a buffer.</p>
        <table class="parameters" id="filter-parameters">
            <caption>Parameters</caption>
            <thead>
                <tr>
                    <th>#</th>
                    <th>Reason</th>
                    <th>Mask Bit</th>
                    <th>Parameter Name</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>0</td>
                    <td></td>
                    <td>100000</td>
                    <td>Input Buffer</td>
                    <td>The buffer which is to have a filter applied to it.</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td></td>
                    <td>080000</td>
                    <td>Input Buffer Position</td>
                    <td>The position which the input buffer will start from.  This is an int in this case since this kind of channel can't do time based operations.</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td></td>
                    <td>040000</td>
                    <td>Output Buffer</td>
                    <td>The buffer which this channel will output to.</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td></td>
                    <td>020000</td>
                    <td>Output Buffer Position</td>
                    <td>The position of the output buffer where output will begin.</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td></td>
                    <td>010000</td>
                    <td>Filter Buffer</td>
                    <td>The buffer which will contain the filter kernel or kernels for the convolution.</td>
                </tr>
                <tr>
                    <td>5</td>
                    <td></td>
                    <td>008000</td>
                    <td>Filter Buffer Start</td>
                    <td>The start position within the buffer where filters are to be found.  This value is, unlike all other offset values, in samples.</td>
                </tr>
                <tr>
                    <td>6</td>
                    <td></td>
                    <td>004000</td>
                    <td>Filter Buffer Slices</td>
                    <td>The number of same-size filter kernels which follow from the start.</td>
                </tr>
                <tr>
                    <td>7</td>
                    <td></td>
                    <td>002000</td>
                    <td>Selected Slice</td>
                    <td>The filter slice which is to be selected starting from the filter start.  Starting from 0.</td>
                </tr>
                <tr>
                    <td>8</td>
                    <td></td>
                    <td>001000</td>
                    <td>Slice Source</td>
                    <td>A buffer which will be used to select slices.  0.0 is the first slice and 1.0 is the last slice, and the nearest slice in between will be selected.</td>
                </tr>
                <tr>
                    <td>9</td>
                    <td></td>
                    <td>000800</td>
                    <td>Filter Mode</td>
                    <td><a href="#automation-modes">Either SYNTH_AUTO_CONSTANT or SYNTH_AUTO_SOURCE.</a></td>
                </tr>
                <tr>
                    <td>10</td>
                    <td></td>
                    <td>000400</td>
                    <td>Output Mode</td>
                    <td><a href="#output-modes">Either SYNTH_OUTPUT_REPLACE or SYNTH_OUTPUT_ADD.</a></td>
                </tr>
                <tr>
                    <td>11</td>
                    <td></td>
                    <td>000200</td>
                    <td>Volume</td>
                    <td>The base output volume for this filter.</td>
                </tr>
                <tr>
                    <td>12</td>
                    <td></td>
                    <td>000100</td>
                    <td>Volume Source</td>
                    <td>A source buffer for volume, like the player Volume Source.</td>
                </tr>
                <tr>
                    <td>13</td>
                    <td></td>
                    <td>000080</td>
                    <td>Volume Mode</td>
                    <td><a href="#automation-modes">Either SYNTH_AUTO_CONSTANT or SYNTH_AUTO_SOURCE.</a></td>
                </tr>
                <tr>
                    <td>14</td>
                    <td></td>
                    <td>000040</td>
                    <td>Run Length</td>
                    <td>How much time to try to output.</td>
                </tr>
                <tr>
                    <td>15</td>
                    <td>0</td>
                    <td>000020</td>
                    <td>Requested Time Met</td>
                    <td>Applied when the Run Length has been met.</td>
                </tr>
                <tr>
                    <td>16</td>
                    <td>01</td>
                    <td>000010</td>
                    <td>Output Buffer Filled</td>
                    <td>Applied when the output buffer has been filled.</td>
                </tr>
                <tr>
                    <td>17</td>
                    <td>02</td>
                    <td>000008</td>
                    <td>Input Buffer Exhausted</td>
                    <td>Applied when the input source buffer has run out.</td>
                </tr>
                <tr>
                    <td>18</td>
                    <td>04</td>
                    <td>000004</td>
                    <td>Volume Buffer Exhausted</td>
                    <td>Applied when the volume source buffer has run out.</td>
                </tr>
                <tr>
                    <td>19</td>
                    <td>20</td>
                    <td>000002</td>
                    <td>Slice Buffer Exhausted</td>
                    <td>Applied when the slice source buffer has run out.</td>
                </tr>
                <tr>
                    <td>20</td>
                    <td></td>
                    <td>000001</td>
                    <td>Filter Size</td>
                    <td>This specifies the size of the filter for the initial state.  This can't be changed once it's set and will be ignored if provided on a sequence line.</td>
                </tr>
            </tbody>
        </table>
        <hr>
        <h2 id="debug-output">Debug Output</h2>
        <p>This part isn't really likely to be stable and consistent and a lot of it's mostly just stuff i threw in while working on stuff.  It does seem useful for tracing what's going on during playback, though.  I won't bother documenting all of it but I'll document what's important.  The sequencer needs to have tracing enabled for this stuff to be output, otherwise it'll just be errors.</p>
        <h3 id="debug-parser-output">Debug Parser Output</h3>
        <p>While a file is being read, each input line will be printed, followed by the output after parsing macros.  For example:</p>
        <code>0: CrustyTracker
-&gt; CrustyTracker
1: 2 2
-&gt; 2 2
. . .</code>
        <p>The parser will then print all the unique lines it's found with their numbers.<p>
        <code>0 [0]
1 [None, 0, None, None, None]
. . .</code>
        <h3 id="debug-sequencer-output">Debug Sequencer Output</h3>
        <p>While a sequence is playing, a lot of information will be printed showing what's happening and hopefully why.</p>
        <p>When the underlying synth engine calls the audio callback needing audio, the output will look like this for example.</p>
        <code>=== Audio Callback 16 ===</code>
        <p>Where 16 is the amount of milliseconds requested.</p>
        <p>For each callback, the channels will be run in order for each line of events in the file, or to continue/complete an event in process between callbacks.  The output for a call to run an event looks like:</p>
        <code>=== run_channels === 768</code>
        <p>Where 768 is the amount of samples needed from the underlying synthesizer to fulfill/continue/complete the event.</p>
        <p>Each channel with new line event will be printed with the line number followed by a list of parameters.  These parameters are in the order in the parameter tables.  None indicates no update and for parameter change updates, a number indicates that the numbered line will be used for the parameter change, and a -1 means that the parameter change will be unset.  It looks like this:</p>
        <code>8 [None, None, 5000, None, None]</code>
        <p>Each line will be followed by how many samples the synth engine returned.</p>
        <code>8 +768</code>
        <p>If this value is +0, it'll be followed by a line with the requested time remaining followed by the "reason" why there was 0 samples returned.  If the reason is 0, and the time remaining is not 0, then there was no reason, which shouldn't happen!  But if both are 0, it doesn't mean the synthesizer had any reason to stop continuing, but that the requested amount of time had simply passed.  These refer to the binary OR'd together reason values in the parameter tables, in hex.</p>
        <code>8 192000 1</code>
        <p>Followed by a list of any changes applied.</p>
        <code>[None, 0, None, None, None]</code>
        <hr>
    </body>
</html>
